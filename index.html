<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>跳动的爱心粒子动画</title>
<style>
  body {margin:0; background:black; overflow:hidden;}
  canvas {display:block; margin:0 auto;}
</style>
</head>
<body>
<canvas id="heart"></canvas>
<script>
const canvas = document.getElementById("heart");
const ctx = canvas.getContext("2d");

const CANVAS_WIDTH = 640;
const CANVAS_HEIGHT = 480;
canvas.width = CANVAS_WIDTH;
canvas.height = CANVAS_HEIGHT;
const CENTER_X = CANVAS_WIDTH / 2;
const CENTER_Y = CANVAS_HEIGHT / 2;
const IMAGE_ENLARGE = 11;
const HEART_COLOR = "#FFC0CB";

function heartFunction(t, shrink=IMAGE_ENLARGE){
    const x = 16 * Math.pow(Math.sin(t),3);
    const y = -(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t));
    return [x*shrink + CENTER_X, y*shrink + CENTER_Y];
}

function scatterInside(x, y, beta=0.15){
    const ratio_x = -beta * Math.log(Math.random());
    const ratio_y = -beta * Math.log(Math.random());
    const dx = ratio_x * (x - CENTER_X);
    const dy = ratio_y * (y - CENTER_Y);
    return [x - dx, y - dy];
}

function shrink(x, y, ratio){
    const force = -1 / Math.pow(((x-CENTER_X)**2 + (y-CENTER_Y)**2), 0.6);
    const dx = ratio * force * (x - CENTER_X);
    const dy = ratio * force * (y - CENTER_Y);
    return [x - dx, y - dy];
}

function curve(p){
    return 2 * (2 * Math.sin(4*p)) / (2*Math.PI);
}

class Heart {
    constructor(frames=20){
        this.points = [];
        this.edgeDiffusion = [];
        this.centerDiffusion = [];
        this.allPoints = [];
        this.build(2000);
        this.frames = frames;
        for(let f=0; f<frames; f++) this.calc(f);
    }

    build(num){
        for(let i=0; i<num; i++){
            const t = Math.random() * Math.PI * 2;
            const [x,y] = heartFunction(t);
            this.points.push([x,y]);
        }
        for(let [x,y] of this.points){
            for(let i=0;i<3;i++){
                this.edgeDiffusion.push(scatterInside(x,y,0.05));
            }
        }
        for(let i=0;i<4000;i++){
            const [x,y] = this.points[Math.floor(Math.random()*this.points.length)];
            this.centerDiffusion.push(scatterInside(x,y,0.17));
        }
    }

    calcPosition(x,y,ratio){
        const force = 1 / Math.pow(((x-CENTER_X)**2+(y-CENTER_Y)**2),0.520);
        const dx = ratio * force * (x-CENTER_X) + (Math.random()*2-1);
        const dy = ratio * force * (y-CENTER_Y) + (Math.random()*2-1);
        return [x - dx, y - dy];
    }

    calc(frame){
        const ratio = 10 * curve(frame/10*Math.PI);
        const haloRadius = Math.floor(4 + 6*(1+curve(frame/10*Math.PI)));
        const haloNumber = Math.floor(3000 + 4000*Math.pow(Math.abs(curve(frame/10*Math.PI)),2));
        const allPoints = [];

        const haloSet = new Set();
        for(let i=0; i<haloNumber; i++){
            const t = Math.random()*Math.PI*2;
            let [x,y] = heartFunction(t, 11.6);
            [x,y] = shrink(x,y,haloRadius);
            const key = `${Math.round(x)},${Math.round(y)}`;
            if(!haloSet.has(key)){
                haloSet.add(key);
                x += Math.random()*28 - 14;
                y += Math.random()*28 - 14;
                const size = Math.random() < 0.5 ? 1 : 2;
                allPoints.push([x,y,size]);
            }
        }

        for(let [x,y] of this.points){
            [x,y] = this.calcPosition(x,y,ratio);
            allPoints.push([x,y,Math.floor(Math.random()*3)+1]);
        }
        for(let [x,y] of this.edgeDiffusion){
            [x,y] = this.calcPosition(x,y,ratio);
            allPoints.push([x,y,Math.floor(Math.random()*2)+1]);
        }
        for(let [x,y] of this.centerDiffusion){
            [x,y] = this.calcPosition(x,y,ratio);
            allPoints.push([x,y,Math.floor(Math.random()*2)+1]);
        }

        this.allPoints[frame] = allPoints;
    }

    render(ctx, frame){
        const points = this.allPoints[frame % this.frames];
        for(let [x,y,size] of points){
            ctx.fillStyle = HEART_COLOR;
            ctx.fillRect(x, y, size, size);
        }
    }
}

const heart = new Heart();
let frame = 0;
function draw(){
    ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT);
    heart.render(ctx, frame);
    frame++;
    setTimeout(draw, 160);
}
draw();
</script>
</body>
</html>
